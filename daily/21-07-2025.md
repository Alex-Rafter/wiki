## Sinc Perf 

Quick update from me: 
- We have 3 sets of changes live on Sinc now thanks to Mabbs jumping on testing Fri 
- We're making progress but imo testing burden is a bottleneck for getting changes live
- So far we have 3 parts of the initial work (that was reverted on live) deployed and live but we still have at least 1 more (possibly 2) chunks of this work to deploy just to get us back to where we were after the initial go live on 16th
- The initial work needs finishing before i can then get on to the second batch that's required to get us close to a finished piece of work. Using smaller commits like we have here, i estimate there will be 3 more sets of changes to test and deploy in this 2nd part of the work. 
- After we finish those we can start to look at measuring changes to finish off report 
- I am scheduled on new world codebase from today. As we need to factor in the testing time for each set of perf changes, i plan to keep doing work in batches: as each of prev set is tested and deployed on live i'll add another change ready for testing. Hopefully this will mean we can get a flow of testing and deploying work this week that works for everyone.
- Based on what we've got live so far, and schedule for this week, it's going to take some time (maybe end of the week?) to get this up to a point where we can feed back with meaningful improvements to the client.


Global JS Changes

Change 4 - Global JS Changes
The changes here include: 
changing the order in which scripts fire / deferring external scripts
fixing error prone inline scripts
removing dead code

What do we need to testing?
These changes are global and so we need to spot test across the site to make sure: 
Do scripts still fire / work as on live? 
Do plugins still work as on live? 
Does UVD still work as it does on live? tabs, accodions, plugins etc?
Do features and specs etc still work they do on live?


## BP Static Next Sprint - Prep


Goals : 
- First thing is to get the current code merged and cleaned up. This is ahead of new stuff
- End of the sprint - where do we need to be?

All existing stuff brought over and refactored into the new format we need 
We increment these components we add interesting transitions and animations

End of the 2 weeks - we have a fully functioning BP - up to current 
Would be good if we are ready to build something at the end of this 2 weeks. 
Is that realistic? 

We should be ale to move over the existing stuff from BP easily enough? 
Then iterate on it and make it Astro compatible.

What about the static UI workflow?
I think we are better off at this point bringing over what we have and making that right 
Then maybe iterating on that with nice animations
Then we can look to add more new stuff? Its probably better this way given we don't have an concepts - we can work with this for now



Prep 

Do a simple experiment with bringing components over from BP exactly as they are and passing static hardcoded values via the attrs.
Is this an easy way to bring over?
If so, that in itself is a job. 
Next after that would be refactor of those components into better format
First off being moving simple text passed as attr to Astro
Make a list of these to be done: text, simple classes, etc


## Bring Over BSK 1.0 Components to BP Static and Refactor

### Introduction

Because we are using many of the same core dependencies in our current boilerplate and the new BP Static codebase, we should (in most cases) be able to transfer components from our in house UI library to the BP Static.
Because we no longer have the same constraints of the existing codebase, we have a good opportunity to refactor the components to make the templates simpler, and easier to reason about.

### Brief 

- Follow the steps below to bring over all the components in the folder
- Once working and tested, refactor the component in line with the steps laid out in teh brief
- Once the components have been refactored and tested, create a new demo page under `./src/pages/examples/bsk` demoing each component and variation in use


### Step 1 - Bring Over BSK 1.0 Components


For each component within the target directiry in the current boierplate: 

- create a new .astro file for the new component
- name this in PascalCase using the same naming as the existing bsk component minus the 'bsk' namespace eg 
for the component 'bsk-accordion-group' we should have a new .astro file with the filename 'AccordionGroup'
- Copy over the template file exactly as it is initially
- if there is a style tag nested under the template tag, move the whole style tag to the top level - so that it is no longher a child of the template tagh but instead sits as a sibling to the template tag 
- navigate to the component logic in BP 1.0 and copy the variable declaration (minus any export statement) and the object assigned to that variable.
- create a new script tag inside the .astro component
- add the bsk import statement at the top of the new script tag 
eg `import { bsk } from "@bsk";`
- Paste the component logic copied from BP 1.0
- Below that call the bsk function, passing the component inside an object as the only argument to that function
- replace the template tag with the bsk-element attribute with a new custome element tag matched to the value of the bsk-element attribute. 
For example, for the component 'bsk-accordion-group' we would 
- remove the outermost template tag that wraps the petite vue component template
- replace that template tag with a custom element tag with the name of `<bsk-accordion-group></bsk-accordion-group>`
- replace all Vue double mustache syntax with double parentheses.

At this point you should have an astro component with : 

markup wrapped in a bsk custom element tag 
a single style tag with component styles
a single scritp tag with the component logic and a call to the bsk function registering the component 

At this point you should be able to use the component. You can test this by : 
passing hardcoded values via attributes set on the custom element tag


----
### Step 2- Refactor BSK 1.0 Components for BP Static

####  Refactor - Text Interpolation

To do this: 
- start with simple text Interpolation cases (these should have been updated to use double parentheses in the previous step)
- create a new variable of the same new to that of the bsk component property using object destructuring and assign a default value
- update the double parentheses syntax to single moustache syntax 
- at this point you should see the default value set in teh Astro front matter being rendered instead of the default bsk value set in the component logic in the script tag (you might want to try changing the default in the front matter briefly to confirm that the data is pulling from that source)
- You can now test passing new values as props to the Astro component instance 
- After you have finished you will need to clean up the component logic so as to remove the property that had been used as the reactive data source in text interpolation eg


#### Refactor - use Astro dynamic attributes over Vue attribute binding

In some cases we want to use Petite Vue to control reactive data sources that will define attributes and their values as runtime - eg we may want our class names to react and update based on component state. But in many cases, we can simplify the bsk components we are bringing over to use Astro's dynamic attributes instead of Vue's attribute binding. 

To do this: 
- find instances of the `v-bind:` and shorthand `:` synax 
- create a new variable of the same new to that of the bsk component property using object destructuring and assign a default value
- update from the Vue attribute beinding synatx to Astro dyanmic attribute syntax
- at this point you should see the default value set in teh Astro front matter being rendered instead of the default bsk value set in the component logic in the script tag (you might want to try changing the default in the front matter briefly to confirm that the data s pullsing from that source)
- You can now test passing new values as props to the Astro component instance
- You shoukd be able to use this for simple cases where we do not need to use reactive data such as data attributes, class names, ids, etc
- After you have finished you will need to clean up the component logic so as to remove the property that had been used as the reactive data source in attribute binding eg

*If you are not sure if an attribute should be refactored to use dynamic attributes or not - leave these for now - note them and we can review prior to PR.*

#### Refactor styles - using Astro component scoping over bsk namespacing


#### Refactor template - use template inheritance over template logic
In the BSK UI library, component variations are configured using the 'is' property. 
Variations in markup, classes and other attributes; and targeting of some style rules, are handled via the value of the is property. Examples: 

While this works, and has enabled us to make use of component variations within the constraints of the COG platform, it adds complexity to our templates. For example, we may need to use additional template logic (v-if, v-else-if, etc) to define what markup should render for each variant. This can quickly add to cognitive load, and make the template harder to reason about.

Because we do not have the same limitation with the new codebase, we now have a chance to reduce that complexity when creating variations of components. We reduce that complexity by using template inheritance instead of template logic. What is template inheritance?

["Template inheritance is an approach to managing templates that resembles object-oriented programming techniques. Instead of the traditional use of {include ...} tags to manage parts of templates, you can inherit the contents of one template to another (like extending a class) and change blocks of content therein (like overriding methods of a class.) This keeps template management minimal and efficient, since each template only contains the differences from the template it extends."](https://www.smarty.net/docs/en/advanced.features.template.inheritance.tpl)

##### Into to using  template inheritance within Astro components using Astro slots.
- Create a base instance of a component
- For content that will be overridden in variations of the component, markup those sections using a [named slot with fallback content](https://docs.astro.build/en/basics/astro-components/#fallback-content-for-slots)
- For each variation, create a new file, import the base component, override the fallback content in the base component with the new variation-specific markup

###### Refactoring steps 
- Create a copy of the component prior to any refactoring - we will use this for reference as we go.
- Go through the template and remove all but the base instance markup. For example, if the template contains markup to render for a base version and a variant, we remove the markup for the variant and all the related conditional logic (v-if).
- Mark up the base instance markup in that section of the template using a named slot - this will now form the fallback content that will rendering whenever as slot is not used.
- Repeat for all areas of conditional rendering used handle variants (notable by the use of the 'is' property)
- Identify any areas of the template where attribute binding, class binding,  etc is used to set values based on the value of the 'is' property (only those using the 'is' property as the sole condition are suitable for refactoring)
- These sections should be updated to use Astro's dynamic attributes and Astro props to set values.
- identify any styles targeting the is attribute on the custom element `[is="variant-name"]`. These should be moved out to the style tag inside the variant' astro component tha inherits the base template.
  When all the steps are complete you should have 
  - your base astro component with base styles etc, using named slots with fallback (default) content
  - variants as their own astro components, importing the base component and overriding sections of the template with named slots

### Step 3 - Demo Pages

Once all refactoring is done, create a demo of the component use in a sub-page of the Astro examples folder

Notes
All components using Slick JS or other JQuery plugins needs to be re-written. Note these down for now and move on, We can do these as a second batch after the majority are brought over.

Groups of work: 
./accordion
./article
./carousel
./cms-grid
./cog-postback
./cta-section
./custom
./dealerships
./docs
./footer
./gallery
./grids
./hero
./location
./misc
./new-vehicle
./offer-cards
./opening-hours
./page-hero
./recently-viewed
./reviews
./search-filters
./shortlist
./spotlights
./thumbnails
./used-list
./vehicle-card
./vehicle-shared
./version-select